from flask import  Blueprint , jsonify , request , current_app
from models import db , Preset ,  Spaces 
import logging
import os
from flask_cors import CORS
import json


preset_bp = Blueprint('Preset' , __name__)
CORS(preset_bp)

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
 # Assuming your app and db are initialized here

# NOTE: Assuming Spaces and Projects models are also importable from models
# Added Spaces and Projects to the import list for the new functionality
from models import Preset, generate_uuid, Spaces, Projects

# --- Serialization Helper for Spaces (Simplified) ---
def serialize_space(space):
    """Manually serializes a Spaces object to a dictionary with only ID and Name."""
    # Only return space_id and space_name as requested
    return {
        'space_id': space.space_id,
        'space_name': space.space_name,
    }

# --- Serialization Helper for Preset (Updated) ---
def serialize_preset(preset):
    """
    Manually serializes a Preset object to a dictionary, including
    related Spaces details (only space_name) if a space_id is present.
    """
    # Base Preset details - Returning only the requested subset of fields, plus IDs
    data = {
        'preset_id': preset.preset_id,
        'preset_name': preset.preset_name,
        'preset_description': preset.preset_description,
        'space_id': preset.space_id,
        'space_details': None , # Initialize the nested structure
        'project_id':preset.project_id
    }

    # Conditionally fetch and serialize Space details
    if preset.space_id:
        try:
            # Query the Spaces table for the related space
            # Note: In a production app, you might use db.relationship for cleaner access
            space = Spaces.query.get(preset.space_id)

            if space:
                # Add the simplified serialized space details (containing only space_id and space_name)
                data['space_details'] = serialize_space(space)

        except Exception as e:
            # Handle potential database or ORM errors during lookup
            print(f"Error fetching Space {preset.space_id} for Preset: {e}")

    return data

# Helper function (Updated to use the actual Spaces model)
def check_space_exists(space_id):
    """Checks if a space with the given ID exists in the database."""
    # Actual implementation:
    return db.session.query(Spaces).filter_by(space_id=space_id).first() is not None

# --- GET All Presets ---
@preset_bp.route('/presets', methods=['GET'])
def get_presets():
    """Retrieves all presets from the database and returns them as a list of dictionaries."""
    all_presets = Preset.query.all()
    # Manually serialize the list of objects
    result = [serialize_preset(preset) for preset in all_presets]
    return jsonify(result), 200

# --- GET Preset by ID ---
@preset_bp.route('/presets/<string:preset_id>', methods=['GET'])
def get_preset_by_id(preset_id):
    """Retrieves a single preset by its ID."""
    preset = Preset.query.get(preset_id)
    if not preset:
        return jsonify({"message": f"Preset with ID {preset_id} not found"}), 404

    # Manually serialize the single object
    return jsonify(serialize_preset(preset)), 200

# --- POST (Create) a New Preset ---
@preset_bp.route('/presets', methods=['POST'])
def create_preset():
    """Creates a new preset."""
    data = request.get_json()

    # 1. Validation (Basic)
    if not data.get('preset_name') or not data.get('preset_type'):
        return jsonify({"message": "Missing required fields: preset_name and preset_type"}), 400

    # 2. Check Foreign Key (if space_id is provided)
    space_id = data.get('space_id')
    if space_id and not check_space_exists(space_id):
        return jsonify({"message": f"Space with ID {space_id} does not exist"}), 400

    # 3. Create object
    new_preset = Preset(
        preset_name=data['preset_name'],
        preset_description=data.get('preset_description'),
        preset_type=data['preset_type'],
        # Note: preset_id is automatically generated by default=generate_uuid()
        space_id=space_id,
        project_id =data.get('project_id')
    )

    try:
        db.session.add(new_preset)
        db.session.commit()
        # Return the newly created object, serialized manually
        return jsonify(serialize_preset(new_preset)), 201  # 201 Created
    except Exception as e:
        db.session.rollback()
        # Logging the actual error is good practice for debugging
        print(f"Database error on creation: {e}")
        return jsonify({"message": f"Error creating preset: {str(e)}"}), 500

# --- PUT/PATCH (Update) a Preset ---
@preset_bp.route('/presets/<string:preset_id>', methods=['PUT', 'PATCH'])
def update_preset(preset_id):
    """Updates an existing preset by ID."""
    preset = Preset.query.get(preset_id)
    if not preset:
        return jsonify({"message": f"Preset with ID {preset_id} not found"}), 404

    data = request.get_json()

    # Check Foreign Key (if space_id is being updated)
    if 'space_id' in data:
        space_id = data.get('space_id')
        # Allow clearing the foreign key (setting to NULL) if the data passed is null/None
        if space_id is not None and space_id and not check_space_exists(space_id):
            return jsonify({"message": f"Space with ID {space_id} does not exist"}), 400

    # Apply updates dynamically
    try:
        for key, value in data.items():
            # Ensure we only set attributes that exist on the model (security check)
            if hasattr(preset, key) and key != 'preset_id':
                setattr(preset, key, value)

        db.session.commit()
        # Return the updated object, serialized manually
        return jsonify(serialize_preset(preset)), 200  # 200 OK
    except Exception as e:
        db.session.rollback()
        print(f"Database error on update: {e}")
        return jsonify({"message": f"Error updating preset: {str(e)}"}), 500

# --- DELETE a Preset ---
@preset_bp.route('/presets/<string:preset_id>', methods=['DELETE'])
def delete_preset(preset_id):
    """Deletes a preset by ID."""
    preset = Preset.query.get(preset_id)
    if not preset:
        return jsonify({"message": f"Preset with ID {preset_id} not found"}), 404

    try:
        db.session.delete(preset)
        db.session.commit()
        # 204 No Content is standard for successful DELETE, but we return a message + 200
        # If strictly following REST, this should return a 204 and no body.
        return jsonify({"message": f"Preset {preset_id} deleted successfully"}), 200
    except Exception as e:
        db.session.rollback()
        print(f"Database error on deletion: {e}")
        return jsonify({"message": f"Error deleting preset: {str(e)}"}), 500


